#!/bin/sh /etc/rc.common
# Copyright 2018 Alex D (https://gitlab.com/Nooblord/)
# This is free software, licensed under the GNU General Public License v3.

START=99
CONFIG=unlocker

. /lib/functions/network.sh

# Main logic
start()
{
    logger -t UNLOCKER "Starting unlocker."
    
    # Check if already running
    if [ -f /tmp/unlocker_starting.pid ]; then
        read -r unlocker_starting < /tmp/unlocker_starting.pid
        kill -9 "$unlocker_starting" 2>/dev/null
    fi
    # Make pid
    echo $$ > /tmp/unlocker_starting.pid

    # Read settings
    local enabled
    enabled=$(uci get unlocker.@unlocker[0].enabled 2>/dev/null)
    local proxy_mode
    proxy_mode=$(uci get unlocker.@unlocker[0].proxy_mode 2>/dev/null)

    # TODO Checks for ipset, coreutils , curl and all
    # other needed stuff. If not present - exit
    # Next check for check desired proxy_mode reqs
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    if ! command -v ipset >/dev/null; then
        # For safety - do not tamper with pkgs
        # logger -t UNLOCKER "No ipset installed - trying to install and stopping."
        # opkg update && opkg install ipset
        logger -t UNLOCKER "No ipset installed - stopping."
        rm -f /tmp/unlocker_starting.pid  2>/dev/null
        exit 1
    fi

    # If unlocker is disabled - exit
    if [ ! "$enabled" = 1 ]; then
        logger -t UNLOCKER "Unlocker is disabled - exiting."
        rm -f /tmp/unlocker_starting.pid  2>/dev/null
        exit 1
    fi

    logger -t UNLOCKER "Flushing unlocker firewall chains."

    firewall_flush_all

if [ "$proxy_mode" = "T" ]; then
    if ! command -v tor >/dev/null; then
        # For safety - do not tamper with pkgs
        # logger -t "TOR is not installed - trying to install and stopping."
        # opkg update && opkg install tor-geoip
        logger -t "TOR is not installed - stopping."
        rm -f /tmp/unlocker_starting.pid 2>/dev/null
        exit 1
    fi
    logger -t UNLOCKER "TOR is selected - creating chains."
    firewall_create_tor

fi
logger -t UNLOCKER "Finished starting."
rm -f /tmp/unlocker_starting.pid  2>/dev/null
    # Create rules based on desired IP (TODO DNS) lists
}


ipset_destroy_all()
{
    ipset destroy rkn_net 2>/dev/null || ipset flush rkn_net 2>/dev/null
    ipset destroy rkn4 2>/dev/null || ipset flush rkn4 2>/dev/null
    ipset destroy rkn3 2>/dev/null || ipset flush rkn3 2>/dev/null
    ipset destroy rkn2 2>/dev/null || ipset flush rkn2 2>/dev/null
    ipset destroy rkn 2>/dev/null || ipset flush rkn 2>/dev/null
    ipset destroy custom_ip 2>/dev/null || ipset flush custom_ip 2>/dev/null
    ipset destroy custom_net 2>/dev/null || ipset flush custom_net 2>/dev/null
    logger -t UNLOCKER "Destroyed or flushed ip lists in memory"
}

ipset_create()
{
    local iplists
    iplists=$(uci get unlocker.@unlocker[0].iplists 2>/dev/null)
    if [ -z "$iplists" ]; then
        logger -t UNLOCKER "No lists defined for bypassing - exiting."
        exit 1
    fi
    for iplist in $iplists ; do
        case $iplist in
            RKNIPLIST )
                update_rkniplist
                ;;            
            CUSTOMIPLIST )
                update_customiplist
                ;;
        esac
    done
}


update_rkniplist()
{
    local rkniplistcron
    local ipset_download_link
    rkniplistcron=$(uci get unlocker.@unlocker[0].rknListOptions 2>/dev/null)
    
    # determine if device supports https TODO

    if [[ "$(wget -qO - https://nooblord.gitlab.io/ipset-lists/rkn_net.ipset | grep create )" != "" ]]; then
        ipset_download_link="https://nooblord.gitlab.io/ipset-lists"
    else
        ipset_download_link="http://lists.unlocker.xyz"
    fi


    if [ "$rkniplistcron" = "RKNLISTCRON" ]; then
        cron_rkniplist_add
    else
        cron_rkniplist_del
    fi

    if [[ "$(ping -c 1 8.8.8.8 | grep '100% packet loss' )" != "" ]]; then

        logger -t UNLOCKER "Can not update list - internet is down."
    else
        logger -t UNLOCKER "Starting RKNIPLIST update"

        for name in $(ipset list -name | grep rkn); do
            ipset destroy $name 2>/dev/null || ipset flush $name 2>/dev/null
        done

        for name in $(wget -qO - $ipset_download_link/rkn.sets); do
            wget -qO - $ipset_download_link/$name | ipset restore || \
            wget -qO - $ipset_download_link/$name | sed '1d' | ipset restore
        done

        logger -t UNLOCKER "Set RKNIPLIST is updated and loaded in memory"
    fi
}

update_customiplist()
{
        ipset destroy custom_ip 2>/dev/null || ipset flush custom_ip 2>/dev/null
        ipset destroy custom_net 2>/dev/null || ipset flush custom_net 2>/dev/null
        if [ -f /etc/unlocker.ipv4ip ]; then
            cat /etc/unlocker.ipv4ip | ipset restore 2>/dev/null || \
            cat /etc/unlocker.ipv4ip | sed '1d' | ipset restore 2>/dev/null
        fi

        if [ -f /etc/unlocker.ipv4net ]; then
            cat /etc/unlocker.ipv4net | ipset restore 2>/dev/null || \
            cat /etc/unlocker.ipv4net | sed '1d' | ipset restore 2>/dev/null
        fi
        logger -t UNLOCKER "Custom IPSET rules are updated and loaded in memory"
}

cron_rkniplist_add()
{   
    if ! grep -q 'update_rkniplist' /etc/crontabs/root ; then
        mkdir -p /etc/crontabs/ 2>/dev/null
        echo -e '0 0 * * * sh -c ". /etc/init.d/unlocker && update_rkniplist 2>/dev/null"' >> /etc/crontabs/root
        /etc/init.d/cron restart
        /etc/init.d/cron enable
    fi
}

cron_rkniplist_del()
{
    sed -i '/update_rkniplist/d' /etc/crontabs/root
    /etc/init.d/cron restart
}

determine_wg_l3_name()
{
    ubus call network.interface dump | jsonfilter -e '@.interface[@.proto="wireguard"].l3_device'
}

vpnroute_add()
{
    if ! grep -q 'unlockervpn' /etc/iproute2/rt_tables ; then
        echo -e '115 unlockervpn' >> /etc/iproute2/rt_tables
    fi
}

vpnroute_del()
{
    sed -i '/unlockervpn/d' /etc/iproute2/rt_tables
}


firewall_flush_all()
{
    # Remove custom user TCP chain and flush all checks
    if iptables -t nat -F unlocker_check 2>/dev/null; then
        while iptables -t nat -D PREROUTING -p tcp -j unlocker_check 2>/dev/null; do :; done
        iptables -t nat -X unlocker_check 2>/dev/null
    fi

    # Remove custom user tor chain
    iptables -t nat -F unlocker_tor 2>/dev/null
    iptables -t nat -X unlocker_tor 2>/dev/null

    # Remove custom wireguard chain
    logger -t UNLOCKER "Flushed firewall."
}


firewall_create_tor()
{
    local udp_proxy
    local subnets4
    network_get_subnets subnets4 lan
    udp_proxy=$(uci get unlocker.@unlocker[0].udp_proxy 2>/dev/null)
    if [ "$udp_proxy" = "1" ]; then
        logger -t UNLOCKER "UDP option selected - but TOR can't do that, sorry."
    fi
    
    # Create lists for bypass
    ipset_create
    
    # Create new user chains for unlocker check and tor
    iptables -t nat -N unlocker_check 2>/dev/null
    iptables -t nat -N unlocker_tor 2>/dev/null
    
    # Create integration with lists and create tcp prerouting rule for local lan
    for subnet in $subnets4; do
        iptables -t nat -A unlocker_tor -s "$subnet" -p tcp -j REDIRECT --to 9040 2>/dev/null
    done
    
    for ipset in $(ipset list -name | grep '[rkn,custom]' | sort); do
        iptables -t nat -A unlocker_check -m set --match-set "$ipset" dst -j unlocker_tor 2>/dev/null
    done

    iptables -t nat -I PREROUTING -p tcp -j unlocker_check 2>/dev/null

    logger -t UNLOCKER "TOR Chain loaded in firewall"
}

stop()
{
    logger -t UNLOCKER "Stopping unlocker."
    ipset_destroy_all
    firewall_flush_all
    logger -t UNLOCKER "Stopped."
}

reload()
{
    start
}
